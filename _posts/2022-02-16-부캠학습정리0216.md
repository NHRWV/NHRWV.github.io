---
title: "[AI 서비스] ML 프로젝트 라이프 사이클, Linux & Shell Command"
date: 2022-02-16 00:56:00
categories:
- 네이버 부스트캠프 ai tech 3기
tags:
- 부스트캠프
- boostcamp
- 부캠_학습정리
- 글쓰기
---

# 머신러닝 프로젝트 라이프 사이클

## 머신러닝 프로젝트 Flow 

> **문제 정의 >  현상 파악 > 구체적인 문제 정의 > 프로젝트 설계 > 지표 결정 > action > 추가 원인 분석**




### 문제 정의 및 현상 파악

언제나 상황 파악과 문제 정의가 먼저다. 문제 정의란 본질을 파악하는 과정.

1. 현상 파악
2. 구체적으로 문제 정의하기...어떤 문제가 있고, 이걸 어떻게 해결 가능할까..문제를 쪼개서 간단한 부분부터 점진적으로 접근하고 데이터로 해결할 수 있는 걸 생각하기


### 프로젝트 설계

1. 문제 정의
2. 최적화할 metric 선택
3. 데이터 수집 및 레이블 확인
4. 모델 개발
5. 모델 예측 결과를 토대로 에러 분석, 잘못된 라벨이 왜 생기는지 파악
6. 다시 모델 학습 및 추가 데이터 수집
7. 반복적으로 문제 정의 및 해결을 하면서 모델 학습
8. 모델 배포
9. 때로는 metric 수정해야 해서 다시 시작해야할 때도 있다.

결국 문제 정의 후에 프로젝트 설계를 가능한한 구체적으로 하는 게 좋다.

> 프로젝트 설계 : 문제 구체화 > 머신러닝 문제 타당성 확인 > 목표 및 지표 설정 > 제약 조건 > 베이스라인, 프로토타입 > 평가 방법 설계

1. 문제 구체화 :   
  머신러닝 문제는 흥미가 아닌 비즈니스적으로 어떤 가치를 줄 수 있는지에 집중

2. 문제 타당성 확인 :   
  결국 데이터로부터 어떤 함수를 학습하는 과정이기에 필요한 데이터의 종류와 기존 모델이 있는지부터 살펴본다. 물론 머신러닝이 최적의 방법은 아니다. 우선, 현상에 패턴이 있다면 머신러닝을 적용하   기 좋다. 그 다음엔 학습을 위한 목적 함수를 만든다. 그리고 패턴에는 복잡함이 있어야 한다. 너무 쉬운 패턴이라면 머신러닝이 필요 없을테니 물론 당연히 데이터가 존재해야 한다.  

3. 목표 설정과 지표 설정 :   
  goal은 큰, 궁극적인 목표. 반면에 objectives는 세부 목표를 가리킨다. 그런데 최적화하고 싶은 목적 함수가 여러가지인 경우에 이것들이 서로 충돌할 수 있다. 일반적으로 모델을 분리해서 모델을 여   러 개 만드는 게 좋다. 왜냐면 그렇게 해야 유지 보수도 편리하고 학습도 쉽기 때문이다.


4. 제약 조건 :   
  시간이나 예산, 법적인 부분, 윤리 이슈, 기술적 제약, 성능(기준값, 해석 가능 여부 등등 결정)


5. 베이스라인, 프로토타입 :  
  모델이 향상되었다고 판단할 수 있는 베이스라인이 필요하다. 룰 베이스 규칙 설계하기. 간단한 모델부터 시작해서 모델 성능 향상 수치를 테스트 할 수 있다. 
  모델을 활용할 수 있는 환경을 준비해서 피드백 받고, 프로토타입을 만들어서 다른 사람들에게 제공하는 방법도 있다.


6. 평가 방법 설계(metric evaluation) :   
  모델 성능 지표와 별개로 비즈니스 목표에 얼마나 영향을 끼치는지 파악하기.  
  모델 성능 지표와 비즈니스 지표를 잘 정의해야 성과 파악이 가능하다. 당연히 대부분의 경우 이익 극대화가 목표다.



### Action(모델 개발 후 배포 & 모니터링)

앞서 정의한 지표가 어떻게 변하는지 확인


### 추가 원인 분석

새로 발생하는 상황 분석


<br/>

## 비즈니스 모델

당연히 비즈니스에 대한 이해도가 높을 수록 문제 정의를 잘 할 수 있을 것이다. 언제나 비즈니스 모델에서 어떤 데이터가 있고, 그걸로 어떤 가치를 창출할 수 있을지 생각하자.

- 데이터를 활용할 수 있는 부분은 어디인가?
- 어떤 데이터 존재하며, 그 데이터로 할 수 있는 게 무엇인가?
- 모델을 활용한다고 하면 예측의 결과가 어떻게 활용되는가?
- 업무 자동화

<br/>

----------------------------------------------

<br/>

# Linux & Shell Command

shell : 사용자가 문자를 입력해서 컴퓨터에 명령할 수 있도록 하는 프로그램  
터미널 / 콘솔 :  쉘을 실행하기 위해 문자 입력을 받아 컴퓨터에 전달, 프로그램 출력을 화면에 작성  
bash : 리눅스 표준 쉘  
hostname : 컴퓨터 네트워크에 접속된 장치에 할달된 이름. 아이피 대신 기억하기 쉬운 걸로 설정  

### 쉘 사용 이유

- 서버에서 접속해서 사용하는 경우
- crontab 등 Linux의 내장 기능을 활용하는 경우
- 데이터 전처리를 하기 위해 쉘 커맨드를 사용
- Docker를 사용하는 경우
- 수백대의 서버를 관리할 경우
- Jupyter Notebook의 Cell에서 앞에 !를 붙이면 쉘 커맨드가 사용된다
- Test Code 실행
- 배포 파이프라인 실행(Github Action 등에서 실행)


### 쉘 커맨드

- man python :  쉘커맨드 매뉴얼 문서 열기. 종료 : ':q'
- mkdir 폴더 생성하기. e.g) mkdir testfolder
- ls : 현재 접근한 폴더, 파일 확인
- pwd : 현재 폴더 절대 경로
- cd :  폴더 변경하기, 이동하기
- echo :  터미널에 텍스트 출력 print 역할
- vi : vim 편집기로 파일을 생성한다. insert 모드에서만 수정 가능.
- bash : bash로 쉘 스크립트 실행
- sudo : 관리자 권한으로 실행하고 싶을 때 커맨드 앞에 붙인다.
- cp : 파일/폴더 복사
- mv : 파일, 폴더 이동하기(이름 바꿀 때도 활요)
- cat :  특정 파일 내용 출력
- clear : 터미널창 청소
- history : 최근에 입력한 쉘 커맨드 내역 출력
- find :  현재 폴더에서 파일이나 디렉토리 검색
- export : 환경변수 설정 ... e.g) export water='물'.....echo $water
- alias : 현재 별칭으로 설정된 걸 보여준다. 기본 명령어를 줄일 수 있음

- head / tail : 파일 앞과 뒤의 n행 출력...head -n 3 test.sh
- sort : 행 단위 정렬
- uniq :  중복된 행이 연속으로 있는 경우 중복 제거
- grep :  파일에 주어진 패턴 목록과 매칭되는 라인 검색. 얘도 옵션 많다.
- cut :  파일에서 특정 필드 추출
- ps : 현재 실행되고 있는 프로세스 출력하기 -e 모든 프로세스 -f 풀포맷으로 자세히 보여줌


